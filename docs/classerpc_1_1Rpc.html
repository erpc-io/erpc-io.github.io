<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eRPC: erpc::Rpc&lt; TTr &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eRPC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>erpc</b></li><li class="navelem"><a class="el" href="classerpc_1_1Rpc.html">Rpc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classerpc_1_1Rpc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">erpc::Rpc&lt; TTr &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object is the main communication end point in eRPC. Applications use it to create sessions with remote <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> objects, send and receive requests and responses, and run the event loop.  
 <a href="classerpc_1_1Rpc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rpc_8h_source.html">rpc.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaae8e09ecd3d4e14c6e241fd635aaf70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#aaae8e09ecd3d4e14c6e241fd635aaf70">Rpc</a> (<a class="el" href="classerpc_1_1Nexus.html">Nexus</a> *nexus, void *context, uint8_t rpc_id, sm_handler_t sm_handler, uint8_t phy_port=0)</td></tr>
<tr class="memdesc:aaae8e09ecd3d4e14c6e241fd635aaf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object.  <a href="#aaae8e09ecd3d4e14c6e241fd635aaf70">More...</a><br /></td></tr>
<tr class="separator:aaae8e09ecd3d4e14c6e241fd635aaf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88439d20fe2025f38631ae262fabe3e1"><td class="memItemLeft" align="right" valign="top"><a id="a88439d20fe2025f38631ae262fabe3e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a88439d20fe2025f38631ae262fabe3e1">~Rpc</a> ()</td></tr>
<tr class="memdesc:a88439d20fe2025f38631ae262fabe3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> from a foreground thread. <br /></td></tr>
<tr class="separator:a88439d20fe2025f38631ae262fabe3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391b3358861f5e26df6e2dd0cbe42bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a391b3358861f5e26df6e2dd0cbe42bb6">alloc_msg_buffer</a> (size_t max_data_size)</td></tr>
<tr class="memdesc:a391b3358861f5e26df6e2dd0cbe42bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hugepage-backed buffer for storing request or response messages.  <a href="#a391b3358861f5e26df6e2dd0cbe42bb6">More...</a><br /></td></tr>
<tr class="separator:a391b3358861f5e26df6e2dd0cbe42bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07c5907fdc38d19c5e4d99089d18b58"><td class="memItemLeft" align="right" valign="top"><a id="ad07c5907fdc38d19c5e4d99089d18b58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ad07c5907fdc38d19c5e4d99089d18b58">free_msg_buffer</a> (<a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> msg_buffer)</td></tr>
<tr class="memdesc:ad07c5907fdc38d19c5e4d99089d18b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> created by <a class="el" href="classerpc_1_1Rpc.html#a391b3358861f5e26df6e2dd0cbe42bb6" title="Create a hugepage-backed buffer for storing request or response messages.">alloc_msg_buffer()</a> <br /></td></tr>
<tr class="separator:ad07c5907fdc38d19c5e4d99089d18b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8417f74c49b312695ac6bf5307df7943"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a8417f74c49b312695ac6bf5307df7943">create_session</a> (std::string remote_uri, uint8_t rem_rpc_id)</td></tr>
<tr class="memdesc:a8417f74c49b312695ac6bf5307df7943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a session to a remote <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object and initiate session connection. A session management callback of type <code>kConnected</code> or <code>kConnectFailed</code> will be invoked if this call is successful.  <a href="#a8417f74c49b312695ac6bf5307df7943">More...</a><br /></td></tr>
<tr class="separator:a8417f74c49b312695ac6bf5307df7943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71925e444cb9ff423f68a63c71175d71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a71925e444cb9ff423f68a63c71175d71">destroy_session</a> (int session_num)</td></tr>
<tr class="memdesc:a71925e444cb9ff423f68a63c71175d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect and destroy a session. The application must not use this session number after this function is called.  <a href="#a71925e444cb9ff423f68a63c71175d71">More...</a><br /></td></tr>
<tr class="separator:a71925e444cb9ff423f68a63c71175d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c507035ed2be98a21022d8466d6229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a44c507035ed2be98a21022d8466d6229">enqueue_request</a> (int session_num, uint8_t req_type, <a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *req_msgbuf, <a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *resp_msgbuf, <a class="el" href="classerpc_1_1Rpc.html#a462be99bcda87d2d583a84a6a92565e8">erpc_cont_func_t</a> cont_func, void *tag, size_t cont_etid=kInvalidBgETid)</td></tr>
<tr class="memdesc:a44c507035ed2be98a21022d8466d6229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a request for transmission. This always succeeds. eRPC owns <code>msg_buffer</code> until it invokes the continuation callback.  <a href="#a44c507035ed2be98a21022d8466d6229">More...</a><br /></td></tr>
<tr class="separator:a44c507035ed2be98a21022d8466d6229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8932e69d2b10653e70b5cb06785efb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ac8932e69d2b10653e70b5cb06785efb1">enqueue_response</a> (ReqHandle *req_handle, <a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *resp_msgbuf)</td></tr>
<tr class="memdesc:ac8932e69d2b10653e70b5cb06785efb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a response for transmission at the server. See ReqHandle for details about creating the response. On calling this, the application loses ownership of the request and response <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a>.  <a href="#ac8932e69d2b10653e70b5cb06785efb1">More...</a><br /></td></tr>
<tr class="separator:ac8932e69d2b10653e70b5cb06785efb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c15e4b8c227c6b5109d56558947e484"><td class="memItemLeft" align="right" valign="top"><a id="a7c15e4b8c227c6b5109d56558947e484"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a7c15e4b8c227c6b5109d56558947e484">run_event_loop</a> (size_t timeout_ms)</td></tr>
<tr class="memdesc:a7c15e4b8c227c6b5109d56558947e484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the event loop for some milliseconds. <br /></td></tr>
<tr class="separator:a7c15e4b8c227c6b5109d56558947e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1a36500cd81962e22d7b243a157aaf"><td class="memItemLeft" align="right" valign="top"><a id="a9f1a36500cd81962e22d7b243a157aaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a9f1a36500cd81962e22d7b243a157aaf">run_event_loop_once</a> ()</td></tr>
<tr class="memdesc:a9f1a36500cd81962e22d7b243a157aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the event loop once. <br /></td></tr>
<tr class="separator:a9f1a36500cd81962e22d7b243a157aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e13737600feff6a35daf9992e5ceb3"><td class="memItemLeft" align="right" valign="top"><a id="aa5e13737600feff6a35daf9992e5ceb3"></a>
<a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#aa5e13737600feff6a35daf9992e5ceb3">alloc_msg_buffer_or_die</a> (size_t max_data_size)</td></tr>
<tr class="memdesc:aa5e13737600feff6a35daf9992e5ceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classerpc_1_1Rpc.html#a391b3358861f5e26df6e2dd0cbe42bb6" title="Create a hugepage-backed buffer for storing request or response messages.">alloc_msg_buffer()</a>, but throws an exception on failure. <br /></td></tr>
<tr class="separator:aa5e13737600feff6a35daf9992e5ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fa4a46f9a7ebc5a5454658205f9fad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a88fa4a46f9a7ebc5a5454658205f9fad">num_active_sessions</a> ()</td></tr>
<tr class="separator:a88fa4a46f9a7ebc5a5454658205f9fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ac34b28eea97e2f4f5eab362785022"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a10ac34b28eea97e2f4f5eab362785022">is_connected</a> (int session_num) const</td></tr>
<tr class="separator:a10ac34b28eea97e2f4f5eab362785022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d52102335a428a2a597390c61ad627"><td class="memItemLeft" align="right" valign="top"><a id="ab8d52102335a428a2a597390c61ad627"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ab8d52102335a428a2a597390c61ad627">get_bandwidth</a> () const</td></tr>
<tr class="memdesc:ab8d52102335a428a2a597390c61ad627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the physical link bandwidth (bytes per second) <br /></td></tr>
<tr class="separator:ab8d52102335a428a2a597390c61ad627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af132359098f294636ea4c9235078a494"><td class="memItemLeft" align="right" valign="top"><a id="af132359098f294636ea4c9235078a494"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#af132359098f294636ea4c9235078a494">get_num_re_tx</a> (int session_num) const</td></tr>
<tr class="memdesc:af132359098f294636ea4c9235078a494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of retransmissions for a connected session. <br /></td></tr>
<tr class="separator:af132359098f294636ea4c9235078a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f932251e23faf24ba5c9ccde9202a"><td class="memItemLeft" align="right" valign="top"><a id="a393f932251e23faf24ba5c9ccde9202a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a393f932251e23faf24ba5c9ccde9202a">reset_num_re_tx</a> (int session_num)</td></tr>
<tr class="memdesc:a393f932251e23faf24ba5c9ccde9202a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the number of retransmissions for a connected session. <br /></td></tr>
<tr class="separator:a393f932251e23faf24ba5c9ccde9202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854b7f1e3b410a8bf9db5c3f4ff735d9"><td class="memItemLeft" align="right" valign="top"><a id="a854b7f1e3b410a8bf9db5c3f4ff735d9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a854b7f1e3b410a8bf9db5c3f4ff735d9">get_stat_user_alloc_tot</a> ()</td></tr>
<tr class="memdesc:a854b7f1e3b410a8bf9db5c3f4ff735d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total amount of huge page memory allocated to the user. <br /></td></tr>
<tr class="separator:a854b7f1e3b410a8bf9db5c3f4ff735d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1750c34c1af61f0943cc047fc14b43f7"><td class="memItemLeft" align="right" valign="top"><a id="a1750c34c1af61f0943cc047fc14b43f7"></a>
Timely *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a1750c34c1af61f0943cc047fc14b43f7">get_timely</a> (int session_num)</td></tr>
<tr class="memdesc:a1750c34c1af61f0943cc047fc14b43f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Timely instance for a connected session. Expert use only. <br /></td></tr>
<tr class="separator:a1750c34c1af61f0943cc047fc14b43f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8313c94b0c5924ec4af8bbdf0ddc6846"><td class="memItemLeft" align="right" valign="top"><a id="a8313c94b0c5924ec4af8bbdf0ddc6846"></a>
TimingWheel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a8313c94b0c5924ec4af8bbdf0ddc6846">get_wheel</a> ()</td></tr>
<tr class="memdesc:a8313c94b0c5924ec4af8bbdf0ddc6846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Timing Wheel for this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a>. Expert use only. <br /></td></tr>
<tr class="separator:a8313c94b0c5924ec4af8bbdf0ddc6846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a51d1f19de5bc3ed9d11404aad5f7d9"><td class="memItemLeft" align="right" valign="top"><a id="a8a51d1f19de5bc3ed9d11404aad5f7d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a8a51d1f19de5bc3ed9d11404aad5f7d9">set_context</a> (void *_context)</td></tr>
<tr class="memdesc:a8a51d1f19de5bc3ed9d11404aad5f7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a>'s context. <br /></td></tr>
<tr class="separator:a8a51d1f19de5bc3ed9d11404aad5f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1329fd8371f51a09ab92df71951d75c"><td class="memItemLeft" align="right" valign="top"><a id="ac1329fd8371f51a09ab92df71951d75c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ac1329fd8371f51a09ab92df71951d75c">set_pre_resp_msgbuf_size</a> (size_t new_pre_resp_msgbuf_size)</td></tr>
<tr class="memdesc:ac1329fd8371f51a09ab92df71951d75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a>'s preallocated response message buffer size. <br /></td></tr>
<tr class="separator:ac1329fd8371f51a09ab92df71951d75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127ef347a5c6e1efde00a98f33e51acb"><td class="memItemLeft" align="right" valign="top"><a id="a127ef347a5c6e1efde00a98f33e51acb"></a>
HugeAlloc *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a127ef347a5c6e1efde00a98f33e51acb">get_huge_alloc</a> () const</td></tr>
<tr class="memdesc:a127ef347a5c6e1efde00a98f33e51acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a>'s hugepage allocator. For expert use only. <br /></td></tr>
<tr class="separator:a127ef347a5c6e1efde00a98f33e51acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093c90bcda2143352e77b3481989828a"><td class="memItemLeft" align="right" valign="top"><a id="a093c90bcda2143352e77b3481989828a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a093c90bcda2143352e77b3481989828a">get_remote_hostname</a> (int session_num) const</td></tr>
<tr class="memdesc:a093c90bcda2143352e77b3481989828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hostname of the remote endpoint for a connected session. <br /></td></tr>
<tr class="separator:a093c90bcda2143352e77b3481989828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24abbcf2416e6e1acf91142757c44460"><td class="memItemLeft" align="right" valign="top"><a id="a24abbcf2416e6e1acf91142757c44460"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a24abbcf2416e6e1acf91142757c44460">get_rpc_id</a> () const</td></tr>
<tr class="memdesc:a24abbcf2416e6e1acf91142757c44460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ID of this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object. <br /></td></tr>
<tr class="separator:a24abbcf2416e6e1acf91142757c44460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08d1b5575c5a126e75ebfef0616cce8"><td class="memItemLeft" align="right" valign="top"><a id="aa08d1b5575c5a126e75ebfef0616cce8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#aa08d1b5575c5a126e75ebfef0616cce8">in_background</a> () const</td></tr>
<tr class="memdesc:aa08d1b5575c5a126e75ebfef0616cce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the caller is running in a background thread. <br /></td></tr>
<tr class="separator:aa08d1b5575c5a126e75ebfef0616cce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af705b58c0c10fbe3bd7e3000a2d82a79"><td class="memItemLeft" align="right" valign="top"><a id="af705b58c0c10fbe3bd7e3000a2d82a79"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#af705b58c0c10fbe3bd7e3000a2d82a79">get_etid</a> () const</td></tr>
<tr class="memdesc:af705b58c0c10fbe3bd7e3000a2d82a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eRPC thread ID of the caller. <br /></td></tr>
<tr class="separator:af705b58c0c10fbe3bd7e3000a2d82a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9c6188ce7c2c1812f7056694a94164"><td class="memItemLeft" align="right" valign="top"><a id="adf9c6188ce7c2c1812f7056694a94164"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#adf9c6188ce7c2c1812f7056694a94164">get_freq_ghz</a> () const</td></tr>
<tr class="memdesc:adf9c6188ce7c2c1812f7056694a94164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return RDTSC frequency in GHz. <br /></td></tr>
<tr class="separator:adf9c6188ce7c2c1812f7056694a94164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1041591e9b79ee8da00bc3b6d071ae2"><td class="memItemLeft" align="right" valign="top"><a id="ab1041591e9b79ee8da00bc3b6d071ae2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ab1041591e9b79ee8da00bc3b6d071ae2">sec_since_creation</a> ()</td></tr>
<tr class="memdesc:ab1041591e9b79ee8da00bc3b6d071ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of seconds elapsed since this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> was created. <br /></td></tr>
<tr class="separator:ab1041591e9b79ee8da00bc3b6d071ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2c9b1fee1a6e04612daf38450d7ece"><td class="memItemLeft" align="right" valign="top"><a id="a6a2c9b1fee1a6e04612daf38450d7ece"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a6a2c9b1fee1a6e04612daf38450d7ece">get_avg_rx_batch</a> ()</td></tr>
<tr class="memdesc:a6a2c9b1fee1a6e04612daf38450d7ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average number of packets received in a call to rx_burst. <br /></td></tr>
<tr class="separator:a6a2c9b1fee1a6e04612daf38450d7ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfa3c973ce3445c07a1bfac744433c0"><td class="memItemLeft" align="right" valign="top"><a id="aecfa3c973ce3445c07a1bfac744433c0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#aecfa3c973ce3445c07a1bfac744433c0">get_avg_tx_batch</a> ()</td></tr>
<tr class="memdesc:aecfa3c973ce3445c07a1bfac744433c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average number of packets sent in a call to tx_burst. <br /></td></tr>
<tr class="separator:aecfa3c973ce3445c07a1bfac744433c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68f74570aaa40e470c2c2d398a1b826"><td class="memItemLeft" align="right" valign="top"><a id="ae68f74570aaa40e470c2c2d398a1b826"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ae68f74570aaa40e470c2c2d398a1b826">reset_dpath_stats</a> ()</td></tr>
<tr class="memdesc:ae68f74570aaa40e470c2c2d398a1b826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all datapath stats to zero. <br /></td></tr>
<tr class="separator:ae68f74570aaa40e470c2c2d398a1b826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1064a9afcc2d992009e17893fed90dc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a1064a9afcc2d992009e17893fed90dc1">fault_inject_fail_resolve_rinfo_st</a> ()</td></tr>
<tr class="memdesc:a1064a9afcc2d992009e17893fed90dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject a fault that always fails all routing info resolution.  <a href="#a1064a9afcc2d992009e17893fed90dc1">More...</a><br /></td></tr>
<tr class="separator:a1064a9afcc2d992009e17893fed90dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af324461e6e58250d33150d91bc39a48e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#af324461e6e58250d33150d91bc39a48e">fault_inject_set_pkt_drop_prob_st</a> (double <a class="el" href="classerpc_1_1Rpc.html#a818aa0efcaa3ab909e09cd87034a1ad1">pkt_drop_prob</a>)</td></tr>
<tr class="memdesc:af324461e6e58250d33150d91bc39a48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TX packet drop probability for this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a>.  <a href="#af324461e6e58250d33150d91bc39a48e">More...</a><br /></td></tr>
<tr class="separator:af324461e6e58250d33150d91bc39a48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0c99d68d7db5969e7fa374a63d35fb92"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a0c99d68d7db5969e7fa374a63d35fb92">resize_msg_buffer</a> (<a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *msg_buffer, size_t new_data_size)</td></tr>
<tr class="memdesc:a0c99d68d7db5969e7fa374a63d35fb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> to fit a request or response.  <a href="#a0c99d68d7db5969e7fa374a63d35fb92">More...</a><br /></td></tr>
<tr class="separator:a0c99d68d7db5969e7fa374a63d35fb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95384c7cbafcfedf532227717d19b02"><td class="memItemLeft" align="right" valign="top"><a id="ab95384c7cbafcfedf532227717d19b02"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ab95384c7cbafcfedf532227717d19b02">get_max_data_per_pkt</a> ()</td></tr>
<tr class="memdesc:ab95384c7cbafcfedf532227717d19b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum <em>data</em> size in one packet for the (private) transport. <br /></td></tr>
<tr class="separator:ab95384c7cbafcfedf532227717d19b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000c61cc3adb015cf17b2e3f862726f8"><td class="memItemLeft" align="right" valign="top"><a id="a000c61cc3adb015cf17b2e3f862726f8"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a000c61cc3adb015cf17b2e3f862726f8">get_max_num_sessions</a> ()</td></tr>
<tr class="memdesc:a000c61cc3adb015cf17b2e3f862726f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of sessions supported. <br /></td></tr>
<tr class="separator:a000c61cc3adb015cf17b2e3f862726f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379b5cfa5d20af4b0d0fd1589862f9be"><td class="memItemLeft" align="right" valign="top"><a id="a379b5cfa5d20af4b0d0fd1589862f9be"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a379b5cfa5d20af4b0d0fd1589862f9be">get_max_msg_size</a> ()</td></tr>
<tr class="memdesc:a379b5cfa5d20af4b0d0fd1589862f9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data size in bytes that can be sent in one request or response. <br /></td></tr>
<tr class="separator:a379b5cfa5d20af4b0d0fd1589862f9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a470c2e9562ddd9fbf482ac66a922dd71"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a470c2e9562ddd9fbf482ac66a922dd71">kMaxMsgSize</a></td></tr>
<tr class="memdesc:a470c2e9562ddd9fbf482ac66a922dd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max request or response <em>data</em> size, i.e., excluding packet headers.  <a href="#a470c2e9562ddd9fbf482ac66a922dd71">More...</a><br /></td></tr>
<tr class="separator:a470c2e9562ddd9fbf482ac66a922dd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p class="">(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a18236cb88db9fa44f0a5a4dffaffd07c"><td class="memItemLeft" align="right" valign="top"><a id="a18236cb88db9fa44f0a5a4dffaffd07c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a18236cb88db9fa44f0a5a4dffaffd07c">ReqFuncType</a> : uint8_t </td></tr>
<tr class="memdesc:a18236cb88db9fa44f0a5a4dffaffd07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible kinds of request handlers. Foreground-mode handlers run in the thread that calls the event loop. Background-mode handlers run in background threads spawned by eRPC. <br /></td></tr>
<tr class="separator:a18236cb88db9fa44f0a5a4dffaffd07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc4e9a928745c818c129030492602a0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a9dc4e9a928745c818c129030492602a0">erpc_req_func_t</a>) (ReqHandle *req_handle, void *context)</td></tr>
<tr class="memdesc:a9dc4e9a928745c818c129030492602a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the request handler function invoked at the server when a request is received. The application owns the request handle (and therefore the request message buffer) until it calls <a class="el" href="classerpc_1_1Rpc.html#ac8932e69d2b10653e70b5cb06785efb1" title="Enqueue a response for transmission at the server. See ReqHandle for details about creating the respo...">Rpc::enqueue_response</a>.  <a href="#a9dc4e9a928745c818c129030492602a0">More...</a><br /></td></tr>
<tr class="separator:a9dc4e9a928745c818c129030492602a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462be99bcda87d2d583a84a6a92565e8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a462be99bcda87d2d583a84a6a92565e8">erpc_cont_func_t</a>) (void *context, void *tag)</td></tr>
<tr class="memdesc:a462be99bcda87d2d583a84a6a92565e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the continuation callback invoked at the client. This returns ownership of the request and response message buffers that the application supplied in <a class="el" href="classerpc_1_1Rpc.html#a44c507035ed2be98a21022d8466d6229" title="Enqueue a request for transmission. This always succeeds. eRPC owns msg_buffer until it invokes the c...">Rpc::enqueue_request</a> back to the application.  <a href="#a462be99bcda87d2d583a84a6a92565e8">More...</a><br /></td></tr>
<tr class="separator:a462be99bcda87d2d583a84a6a92565e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caaf4d78adfd8fda32864ef869c2036"><td class="memItemLeft" align="right" valign="top"><a id="a3caaf4d78adfd8fda32864ef869c2036"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a3caaf4d78adfd8fda32864ef869c2036">kMaxNumERpcProcesses</a> = 32</td></tr>
<tr class="memdesc:a3caaf4d78adfd8fda32864ef869c2036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of eRPC processes per machine. <br /></td></tr>
<tr class="separator:a3caaf4d78adfd8fda32864ef869c2036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac879161a41d83076d538819d555a3643"><td class="memItemLeft" align="right" valign="top"><a id="ac879161a41d83076d538819d555a3643"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ac879161a41d83076d538819d555a3643">kMaxRpcId</a> = UINT8_MAX - 1</td></tr>
<tr class="memdesc:ac879161a41d83076d538819d555a3643"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum ID of an <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object. <br /></td></tr>
<tr class="separator:ac879161a41d83076d538819d555a3643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b722e4bc5dcde570ab474ff79d0159c"><td class="memItemLeft" align="right" valign="top"><a id="a8b722e4bc5dcde570ab474ff79d0159c"></a>
static constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a8b722e4bc5dcde570ab474ff79d0159c">kBaseSmUdpPort</a> = 31850</td></tr>
<tr class="memdesc:a8b722e4bc5dcde570ab474ff79d0159c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The management port for an eRPC processes must be between kBaseSmUdpPort and (kBaseSmUdpPort + kMaxNumERpcProcesses) <br /></td></tr>
<tr class="separator:a8b722e4bc5dcde570ab474ff79d0159c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf5286cfa62fc2712b397926eac8c4f"><td class="memItemLeft" align="right" valign="top"><a id="accf5286cfa62fc2712b397926eac8c4f"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#accf5286cfa62fc2712b397926eac8c4f">kMaxNumaNodes</a> = 8</td></tr>
<tr class="memdesc:accf5286cfa62fc2712b397926eac8c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of NUMA nodes per machine. <br /></td></tr>
<tr class="separator:accf5286cfa62fc2712b397926eac8c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8d4b1300456a7a0b4f433eb82e79f7"><td class="memItemLeft" align="right" valign="top"><a id="a2a8d4b1300456a7a0b4f433eb82e79f7"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a2a8d4b1300456a7a0b4f433eb82e79f7">kMaxBgThreads</a> = 8</td></tr>
<tr class="memdesc:a2a8d4b1300456a7a0b4f433eb82e79f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of background threads per process. <br /></td></tr>
<tr class="separator:a2a8d4b1300456a7a0b4f433eb82e79f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9508616fa3810e28b89be6474c6a86c"><td class="memItemLeft" align="right" valign="top"><a id="ad9508616fa3810e28b89be6474c6a86c"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#ad9508616fa3810e28b89be6474c6a86c">kMaxPhyPorts</a> = 16</td></tr>
<tr class="memdesc:ad9508616fa3810e28b89be6474c6a86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of datapath device ports. <br /></td></tr>
<tr class="separator:ad9508616fa3810e28b89be6474c6a86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718699c7fe5b517f031fa739e4f89a22"><td class="memItemLeft" align="right" valign="top"><a id="a718699c7fe5b517f031fa739e4f89a22"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classerpc_1_1Rpc.html#a718699c7fe5b517f031fa739e4f89a22">kMachineFailureTimeoutMs</a> = 500</td></tr>
<tr class="memdesc:a718699c7fe5b517f031fa739e4f89a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a client cannot ping a remote server for this duration, we assume that the server has failed. If a server does not hear from a client for this duration, we assume that the client has failed. <br /></td></tr>
<tr class="separator:a718699c7fe5b517f031fa739e4f89a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TTr&gt;<br />
class erpc::Rpc&lt; TTr &gt;</h3>

<p class="">An <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object is the main communication end point in eRPC. Applications use it to create sessions with remote <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> objects, send and receive requests and responses, and run the event loop. </p>
<p class="">None of the functions are thread safe. eRPC's worker (background) threads have restricted concurrent access to <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> objects.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTr</td><td>The unreliable transport </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaae8e09ecd3d4e14c6e241fd635aaf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae8e09ecd3d4e14c6e241fd635aaf70">&#9670;&nbsp;</a></span>Rpc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::<a class="el" href="classerpc_1_1Rpc.html">Rpc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classerpc_1_1Nexus.html">Nexus</a> *&#160;</td>
          <td class="paramname"><em>nexus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rpc_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sm_handler_t&#160;</td>
          <td class="paramname"><em>sm_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>phy_port</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nexus</td><td>The <a class="el" href="classerpc_1_1Nexus.html" title="A per-process library object used for initializing eRPC.">Nexus</a> object created by this process </td></tr>
    <tr><td class="paramname">context</td><td>The context passed by the event loop to user callbacks</td></tr>
    <tr><td class="paramname">rpc_id</td><td>Each <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object created by threads of one process must have a unique ID. Users create connections to remote <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> objects by specifying the URI of the remote process, and the remote <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a>'s ID.</td></tr>
    <tr><td class="paramname">sm_handler</td><td>The session management callback that is invoked when sessions are successfully created or destroyed.</td></tr>
    <tr><td class="paramname">phy_port</td><td>An <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object uses one physical port on the NIC. phy_port is the zero-based index of that port among active ports, as listed by <code>ibv_devinfo</code> for Raw, InfiniBand, and RoCE transports; or by <code>dpdk-devbind</code> for DPDK transport.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if construction fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a391b3358861f5e26df6e2dd0cbe42bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391b3358861f5e26df6e2dd0cbe42bb6">&#9670;&nbsp;</a></span>alloc_msg_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::alloc_msg_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_data_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a hugepage-backed buffer for storing request or response messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_data_size</td><td>If this call is successful, the returned <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> contains space for this many application data bytes. The <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> should be resized with <a class="el" href="classerpc_1_1Rpc.html#a0c99d68d7db5969e7fa374a63d35fb92" title="Resize a MsgBuffer to fit a request or response.">resize_msg_buffer()</a> when used for smaller requests or responses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated message buffer. The returned message buffer is invalid (i.e., its <a class="el" href="classerpc_1_1MsgBuffer.html#abeb9af6b4b1497e3aaf2d9779a599f5f">MsgBuffer.buf</a> is null) if we ran out of hugepage memory.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if <code>size</code> is too large for the allocator, or if hugepage reservation failure is catastrophic. An exception is <em>not</em> thrown if allocation fails simply because we ran out of memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The returned <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a>'s <code>buf</code> is surrounded by packet headers for internal use by eRPC. This function does not fill in packet headers, although it sets the magic field in the zeroth header. </dd></dl>

</div>
</div>
<a id="a8417f74c49b312695ac6bf5307df7943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8417f74c49b312695ac6bf5307df7943">&#9670;&nbsp;</a></span>create_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::create_session </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>remote_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rem_rpc_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a session to a remote <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object and initiate session connection. A session management callback of type <code>kConnected</code> or <code>kConnectFailed</code> will be invoked if this call is successful. </p>
<dl class="section return"><dt>Returns</dt><dd>The local session number (&gt;= 0) of the session if the session is successfully created, negative errno otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_uri</td><td>The remote <a class="el" href="classerpc_1_1Nexus.html" title="A per-process library object used for initializing eRPC.">Nexus</a>'s URI, formatted as hostname:udp_port </td></tr>
    <tr><td class="paramname">rem_rpc_id</td><td>The ID of the remote <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71925e444cb9ff423f68a63c71175d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71925e444cb9ff423f68a63c71175d71">&#9670;&nbsp;</a></span>destroy_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::destroy_session </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect and destroy a session. The application must not use this session number after this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_num</td><td>A session number returned from a successful <a class="el" href="classerpc_1_1Rpc.html#a8417f74c49b312695ac6bf5307df7943" title="Create a session to a remote Rpc object and initiate session connection. A session management callbac...">create_session()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the session disconnect packet was sent, and the disconnect callback will be invoked later. Negative errno if the session cannot be disconnected. </dd></dl>

</div>
</div>
<a id="a44c507035ed2be98a21022d8466d6229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c507035ed2be98a21022d8466d6229">&#9670;&nbsp;</a></span>enqueue_request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::enqueue_request </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>req_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>req_msgbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>resp_msgbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classerpc_1_1Rpc.html#a462be99bcda87d2d583a84a6a92565e8">erpc_cont_func_t</a>&#160;</td>
          <td class="paramname"><em>cont_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cont_etid</em> = <code>kInvalidBgETid</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a request for transmission. This always succeeds. eRPC owns <code>msg_buffer</code> until it invokes the continuation callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_num</td><td>The session number to send the request on. This session must be connected.</td></tr>
    <tr><td class="paramname">req_type</td><td>The type of the request. The server for this remote procedure call must have a registered handler for this request type.</td></tr>
    <tr><td class="paramname">req_msgbuf</td><td>The <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> containing the request data</td></tr>
    <tr><td class="paramname">resp_msgbuf</td><td>The <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> that will contain the response data when the continuation is invoked. Its allocation size be large enough to accomodate any response for this request.</td></tr>
    <tr><td class="paramname">cont_func</td><td>The continuation that will be invoked when this request completes. See erpc_req_func_t.</td></tr>
    <tr><td class="paramname">tag</td><td>A tag for this request that will be passed to the application in the continuation callback</td></tr>
    <tr><td class="paramname">cont_etid</td><td>The eRPC thread ID of the background thread to run the continuation on. The default value of <code>kInvalidBgETid</code> means that the continuation runs in the foreground. This argument is meant only for internal use by eRPC (i.e., user calls must ignore it). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8932e69d2b10653e70b5cb06785efb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8932e69d2b10653e70b5cb06785efb1">&#9670;&nbsp;</a></span>enqueue_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::enqueue_response </td>
          <td>(</td>
          <td class="paramtype">ReqHandle *&#160;</td>
          <td class="paramname"><em>req_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>resp_msgbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a response for transmission at the server. See ReqHandle for details about creating the response. On calling this, the application loses ownership of the request and response <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a>. </p>
<p class="">This can be called outside the request handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req_handle</td><td>The handle passed to the request handler by eRPC</td></tr>
    <tr><td class="paramname">resp_msgbuf</td><td>The message buffer containing the response. This must be either the request handle's preallocated response buffer or its dynamic response. The preallocated response buffer may be used for only responses that fit in one packet, in which case it is the better choice.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The restriction on resp_msgbuf is inconvenient to the user because they cannot provide an arbitrary application-owned buffer. Unfortunately, supporting this feature will require passing the response <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> by value instead of reference since eRPC provides no application callback for when the response can be re-used or freed. </dd></dl>

</div>
</div>
<a id="a1064a9afcc2d992009e17893fed90dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1064a9afcc2d992009e17893fed90dc1">&#9670;&nbsp;</a></span>fault_inject_fail_resolve_rinfo_st()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::fault_inject_fail_resolve_rinfo_st </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject a fault that always fails all routing info resolution. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the caller cannot inject faults </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af324461e6e58250d33150d91bc39a48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af324461e6e58250d33150d91bc39a48e">&#9670;&nbsp;</a></span>fault_inject_set_pkt_drop_prob_st()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::fault_inject_set_pkt_drop_prob_st </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pkt_drop_prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the TX packet drop probability for this <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the caller cannot inject faults </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10ac34b28eea97e2f4f5eab362785022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ac34b28eea97e2f4f5eab362785022">&#9670;&nbsp;</a></span>is_connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::is_connected </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return true iff this session is connected. The session must not have been disconnected. </p>

</div>
</div>
<a id="a88fa4a46f9a7ebc5a5454658205f9fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fa4a46f9a7ebc5a5454658205f9fad">&#9670;&nbsp;</a></span>num_active_sessions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::num_active_sessions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return the number of active server or client sessions. This function can be called only from the creator thread. </p>

</div>
</div>
<a id="a0c99d68d7db5969e7fa374a63d35fb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c99d68d7db5969e7fa374a63d35fb92">&#9670;&nbsp;</a></span>resize_msg_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::resize_msg_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classerpc_1_1MsgBuffer.html">MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>msg_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize a <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> to fit a request or response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_buffer</td><td>The <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> to resize</td></tr>
    <tr><td class="paramname">new_data_size</td><td>The new size in bytes of the application data that this <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> should contain. This must be smaller than the size used to create the <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a> in <a class="el" href="classerpc_1_1Rpc.html#a391b3358861f5e26df6e2dd0cbe42bb6" title="Create a hugepage-backed buffer for storing request or response messages.">alloc_msg_buffer()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><code>note</code> This does not modify the <a class="el" href="classerpc_1_1MsgBuffer.html" title="Applications store request and response messages in hugepage-backed buffers called message buffers....">MsgBuffer</a>'s packet headers </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a462be99bcda87d2d583a84a6a92565e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462be99bcda87d2d583a84a6a92565e8">&#9670;&nbsp;</a></span>erpc_cont_func_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* erpc_cont_func_t) (void *context, void *tag)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of the continuation callback invoked at the client. This returns ownership of the request and response message buffers that the application supplied in <a class="el" href="classerpc_1_1Rpc.html#a44c507035ed2be98a21022d8466d6229" title="Enqueue a request for transmission. This always succeeds. eRPC owns msg_buffer until it invokes the c...">Rpc::enqueue_request</a> back to the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context that was used while creating the <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object </td></tr>
    <tr><td class="paramname">tag</td><td>The tag used by the application for this request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dc4e9a928745c818c129030492602a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc4e9a928745c818c129030492602a0">&#9670;&nbsp;</a></span>erpc_req_func_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* erpc_req_func_t) (ReqHandle *req_handle, void *context)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of the request handler function invoked at the server when a request is received. The application owns the request handle (and therefore the request message buffer) until it calls <a class="el" href="classerpc_1_1Rpc.html#ac8932e69d2b10653e70b5cb06785efb1" title="Enqueue a response for transmission at the server. See ReqHandle for details about creating the respo...">Rpc::enqueue_response</a>. </p>
<p class="">The application need not enqueue the response in the body of the request handler. This is true even if the request handler is foreground-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ReqHandle</td><td>A handle to the received request </td></tr>
    <tr><td class="paramname">context</td><td>The context that was used while creating the <a class="el" href="classerpc_1_1Rpc.html" title="An Rpc object is the main communication end point in eRPC. Applications use it to create sessions wit...">Rpc</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a470c2e9562ddd9fbf482ac66a922dd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470c2e9562ddd9fbf482ac66a922dd71">&#9670;&nbsp;</a></span>kMaxMsgSize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::kMaxMsgSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      HugeAlloc::kMaxClassSize -</div><div class="line">      ((HugeAlloc::kMaxClassSize / TTr::kMaxDataPerPkt) * <span class="keyword">sizeof</span>(pkthdr_t))</div></div><!-- fragment -->
<p>Max request or response <em>data</em> size, i.e., excluding packet headers. </p>

</div>
</div>
<a id="a822c8581bd47fa4b56de0349b245581e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822c8581bd47fa4b56de0349b245581e">&#9670;&nbsp;</a></span>pre_resp_msgbuf_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::pre_resp_msgbuf_size = TTr::kMaxDataPerPkt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Size of the preallocated response buffer. This is one packet by default, but some applications might benefit from a larger preallocated buffer, at the expense of increased memory utilization. </p>

</div>
</div>
<a id="a8baad60c0d6377e75f6aa1a73bf0152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8baad60c0d6377e75f6aa1a73bf0152e">&#9670;&nbsp;</a></span>retry_connect_on_invalid_rpc_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::retry_connect_on_invalid_rpc_id = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Retry session connection if the remote RPC ID was invalid. This usually happens when the server RPC thread has not started. </p>

</div>
</div>
<a id="aaeee550545bf4f546bbcb339e199c416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeee550545bf4f546bbcb339e199c416">&#9670;&nbsp;</a></span>still_in_wheel_during_retx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classerpc_1_1Rpc.html">erpc::Rpc</a>&lt; TTr &gt;::still_in_wheel_during_retx = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total retransmissions across all sessions. </p>
<p class="">Number of times we could not retransmit a request, or we had to drop a received packet, because a request reference was still in the wheel. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="nexus_8h_source.html">nexus.h</a></li>
<li>src/<a class="el" href="rpc__types_8h_source.html">rpc_types.h</a></li>
<li>src/<a class="el" href="rpc_8h_source.html">rpc.h</a></li>
<li>src/<a class="el" href="rpc__constants_8h_source.html">rpc_constants.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
